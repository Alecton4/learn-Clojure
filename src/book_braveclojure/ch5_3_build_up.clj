;; Time to build a terminal implementation of Peg Thing
;; using everything you’ve learned so far:
;; immutable data structures, lazy sequences, pure functions, recursion—everything!
;; Doing this will help you understand how to combine these concepts and techniques to solve larger problems.
;; Most important, you’ll learn how to model the changes
;; that result from each move a player makes
;; without having to mutate objects like you would in OOP.

;; ================================
;; Code Organization
;; ================================

;; The program has to handle four major tasks,
;; and the source code is organized accordingly,
;; with the functions for each of these tasks grouped together:
;; - Creating a new board
;; - Returning a board with the result of the player’s move
;; - Representing a board textually
;; - Handling user interaction

;; Two more points about the organization:
;; First, the code has a basic architecture, or conceptual organization, of two layers.
;;   The top layer consists of the functions for handling user interaction.
;;   These functions produce all of the program’s side effects,
;;   printing out the board and presenting prompts for player interaction.
;;   The functions in this layer use the functions in the bottom layer
;;   to create a new board, make moves, and create a textual representation,
;;   but the functions in the bottom layer don’t use those in the top layer at all.
;;   Even for a program this small, a little architecture helps make the code more manageable.
;; Second, I’ve tried as much as possible to decompose tasks into small functions
;;   so that each does one tiny, understandable task.
;;   Some of these functions are used by only one other function.
;;   I find this helpful because it lets me name each tiny subtask,
;;   allowing me to better express the intention of the code.

;; But before all the architecture, there’s this:
(ns ch5-3-build-up
  (:require [clojure.set :as set]) ; Allows you to easily use functions in the clojure.set namespace.
  (:gen-class)) ; Allows you to run the program from the command line.
;; ??? The original code (require [clojure.set :as set]) throw error.

(declare successful-move prompt-move game-over query-rows) ; Allows functions to refer to those names before they’re defined.

;; ================================
;; Creating the Board
;; ================================

;; In this case, you’ll represent the board using a map
;; with numerical keys corresponding to each board position
;; and values containing information about that position’s connections.
;; The map will also contain a :rows key,
;; storing the total number of rows.
{1  {:pegged true, :connections {6 3, 4 2}},
 2  {:pegged true, :connections {9 5, 7 4}},
 3  {:pegged true, :connections {10 6, 8 5}},
 4  {:pegged true, :connections {13 8, 11 7, 6 5, 1 2}},
 5  {:pegged true, :connections {14 9, 12 8}},
 6  {:pegged true, :connections {15 10, 13 9, 4 5, 1 3}},
 7  {:pegged true, :connections {9 8, 2 4}},
 8  {:pegged true, :connections {10 9, 3 5}},
 9  {:pegged true, :connections {7 8, 2 5}},
 10 {:pegged true, :connections {8 9, 3 6}},
 11 {:pegged true, :connections {13 12, 4 7}},
 12 {:pegged true, :connections {14 13, 5 8}},
 13 {:pegged true, :connections {15 14, 11 12, 6 9, 4 8}},
 14 {:pegged true, :connections {12 13, 5 9}},
 15 {:pegged true, :connections {13 14, 6 10}},
 :rows 5}
;; The meaning of :pegged is clear;
;; it represents whether that position has a peg in it.
;; :connections is a bit more cryptic.
;; It’s a map where each key identifies a legal destination,
;; and each value represents the position that would be jumped over.
;; So pegs in position 1, for example, can jump to position 6 over position 3.
;; This might seem backward,
;; but you’ll learn the rationale for it later when you see how move validation is implemented.

;; Now that you’ve seen what the final map representing the board should look like,
;; we can start exploring the functions that actually build up this map in the program.
;; You won’t simply start assigning mutable states willy-nilly
;; to represent each position and whether it’s pegged or not.
;; Instead, you’ll use nested recursive function calls
;; to build up the final board position by position.
;; It’s analogous to the way you created the glamour shot caption earlier,
;; deriving new data from input by passing an argument through a chain of functions
;; to get your final result.

;; The first few expressions in this section of the code deal with triangular numbers.
;; Triangular numbers are generated by adding the first n natural numbers.
;; The first triangular number is 1,
;; the second is 3 (1 + 2),
;; the third is 6 (1 + 2 + 3), and so on.
;; These numbers line up nicely with the position numbers at the end of every row on the board,
;; which will turn out to be a very useful property.
;; First, you define the function tri*,
;; which can create a lazy sequence of triangular numbers:
(defn tri*
  "Generates lazy sequence of triangular numbers"
  ([] (tri* 0 1))
  ([sum n]
   (let [next-sum (+ sum n)]
     (cons next-sum (lazy-seq (tri* next-sum (inc n)))))))

;; NOTE: Review for fun.
(defn tri*'
  "Generates lazy sequence of triangular numbers"
  ([] (tri*' 1 2))
  ([sum n]
   (cons sum (lazy-seq (tri*' (+ sum n) (inc n))))))

(defn tri*''
  "Generates lazy sequence of triangular numbers"
  []
  (letfn [(tri-seq [sum n]
                   (let [next-sum (+ sum n)]
                     (cons next-sum (lazy-seq (tri-seq next-sum (inc n))))))]
    (tri-seq 0 1)))

(defn tri*'''
  "Generates lazy sequence of triangular numbers"
  []
  (map first (iterate (fn [[sum n]] [(+ sum n) (inc n)]) [1 2])))

;; The next expression calls tri*,
;; actually creating the lazy sequence and binding it to tri:
(def tri (tri*))
(take 5 tri)

;; And the next few functions operate on the sequence of triangular numbers.

;; tri-num? figures out if its argument is in the tri lazy sequence.
;; It works by using take-while to create a sequence of triangular numbers
;; whose last element is a triangular number that’s less than or equal to the argument.
;; Then it compares the last element to the argument:
(defn tri-num?
  "Is the number tri-num? e.g. 1, 3, 6, 10, 15, etc"
  [n]
  (= n (last (take-while #(<= % n) tri))))

(tri-num? 5)
(tri-num? 6)

;; Next, there’s row-tri,
;; which takes a row number and gives you the triangular number at the end of that row:
(defn row-tri
  "The triangular number at the end of row n"
  [n]
  (last (take n tri)))

(row-tri 1)
(row-tri 2)
(row-tri 3)

;; Lastly, there’s row-num,
;; which takes a board position and returns the row that it belongs to:
(defn row-num
  "Returns row number the position belongs to: pos 1 in row 1,
  positions 2 and 3 in row 2, etc"
  [pos]
  (inc (count (take-while #(< % pos) tri))))

(row-num 1)
(row-num 5)

;; After that comes connect,
;; which is used to actually form a mutual connection between two positions:
(defn connect
  "Form a mutual connection between two positions"
  [board max-pos pos neighbor destination]
  (if (<= destination max-pos)
    (reduce (fn [new-board [p1 p2]]
              (assoc-in new-board [p1 :connections p2] neighbor))
            board
            [[pos destination] [destination pos]])
    board))

(connect {} 15 1 2 4)
;; The first thing connect does is
;; check whether the destination is actually a position on the board
;; Next, connect uses recursion through reduce to progressively build up the final state of the board.
;; In this example, you’re reducing over the nested vectors [[1 4] [4 1]].
;; This is what allows you to return an updated board
;; with both pos and destination (1 and 4) pointing to each other in their connections.
;; The anonymous function passed to reduce uses a function, assoc-in, which you haven’t seen before.
;; Whereas the function get-in lets you look up values in nested maps,
;; assoc-in lets you return a new map with the given value at the specified nesting.
;; Here are a couple of examples:
(assoc-in {} [:cookie :monster :vocals] "Finntroll")
(get-in {:cookie {:monster {:vocals "Finntroll"}}} [:cookie :monster])
(assoc-in {2 {:connections {8 9}}} [1 :connections 4] 2)

;; Now we have a way to connect two positions,
;; but how should the program choose two positions to connect in the first place?
;; That’s handled by connect-right, connect-down-left, and connect-down-right:
(defn connect-right
  [board max-pos pos]
  (let [neighbor (inc pos)
        destination (inc neighbor)]
    (if-not (or (tri-num? neighbor) (tri-num? pos))
      (connect board max-pos pos neighbor destination)
      board)))

(defn connect-down-left
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ pos row)
        destination (+ neighbor row 1)]
    (connect board max-pos pos neighbor destination)))

(defn connect-down-right
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ pos row 1)
        destination (+ neighbor row 2)]
    (connect board max-pos pos neighbor destination)))
;; These functions each take the board’s max position and a board position
;; and use a little triangle math to figure out which numbers to feed to connect.
;; For example, connect-down-left will attempt to connect position 1 to position 4.
;; In case you’re wondering why the functions connect-left, connect-up-left, and connect-up-right aren’t defined,
;; the reason is that the existing functions actually cover these cases.
;; connect returns a board with the mutual connection established;
;; when 4 connects right to 6, 6 connects left to 4. Here are a couple of examples:
(connect-down-left {} 15 1)
(connect-down-right {} 15 3)

;; The next function, add-pos,
;; is interesting because it actually reduces on a vector of functions,
;; applying each in turn to build up the resulting board.
;; But first it updates the board to indicate that a peg is in the given position:
(defn add-pos
  "Pegs the position and performs connections"
  [board max-pos pos]
  (let [pegged-board (assoc-in board [pos :pegged] true)]
    (reduce (fn [new-board connection-creation-fn]
              (connection-creation-fn new-board max-pos pos))
            pegged-board
            [connect-right connect-down-left connect-down-right])))

(add-pos {} 15 1)

;; Reducing over functions like this is another way of composing functions.
;; To illustrate, here’s another way of defining the clean function
;; in ch5_immu_data_structures.clj: Function Composition Instead of Attribute Mutation
(require '[clojure.string :as s])
(defn clean
  [text]
  (reduce (fn [string string-fn]
            (string-fn string))
          text
          [s/trim #(s/replace % #"lol" "LOL")]))
;; Reducing over a collection of functions is not a technique you’ll use often,
;; but it’s occasionally useful,
;; and it demonstrates the versatility of functional programming.

;; Last among our board creation functions is new-board:
(defn new-board
  "Creates a new board with the given number of rows"
  [rows]
  (let [initial-board {:rows rows}
        max-pos (row-tri rows)]
    (reduce (fn [board pos]
              (add-pos board max-pos pos))
            initial-board
            (range 1 (inc max-pos)))))

;; ================================
;; Moving Pegs
;; ================================

;; The next section of code validates and performs peg moves.
(defn pegged?
  "Does the position have a peg in it?"
  [board pos]
  (get-in board [pos :pegged]))

(defn remove-peg
  "Take the peg at given position out of the board"
  [board pos]
  (assoc-in board [pos :pegged] false))

(defn place-peg
  "Put a peg in the board at given position"
  [board pos]
  (assoc-in board [pos :pegged] true))

(defn move-peg
  "Take peg out of p1 and place it in p2"
  [board p1 p2]
  (place-peg (remove-peg board p1) p2))

;; Next up is valid-moves:
(defn valid-moves
  "Return a map of all valid moves for pos, where the key is the
  destination and the value is the jumped position"
  [board pos]
  (into {}
        (filter (fn [[destination jumped]]
                  (and (not (pegged? board destination))
                       (pegged? board jumped)))
                (get-in board [pos :connections]))))
;; This code goes through each of the given position’s connections
;; and tests whether the destination position is empty and the jumped position has a peg.
;; To see this in action, you can create a board with the 4 position empty:
(def my-board (assoc-in (new-board 5) [4 :pegged] false))

;; Given this board, positions 1, 6, 11, and 13 have valid moves, but all others don’t:
(valid-moves my-board 1)  ; => {4 2}
(valid-moves my-board 6)  ; => {4 5}
(valid-moves my-board 11) ; => {4 7}
(valid-moves my-board 5)  ; => {}
(valid-moves my-board 8)  ; => {}
;; You might be wondering why valid-moves returns a map instead of, say, a set or vector.
;; The reason is that returning a map allows you to easily look up a destination position
;; to check whether a specific move is valid, which is what valid-move? (the next function) does:
(defn valid-move?
  "Return jumped position if the move from p1 to p2 is valid, nil
  otherwise"
  [board p1 p2]
  (get (valid-moves board p1) p2))

(valid-move? my-board 8 4) ; => nil
(valid-move? my-board 1 4) ; => 2

;; Notice that valid-move? looks up the destination position from the map
;; and then returns the position of the peg that would be jumped over.
;; This is another nice benefit of having valid-moves return a map,
;; because the jumped position retrieved from the map
;; is exactly what we want to pass on to the next function, make-move.
;; When you take the time to construct a rich data structure,
;; it’s easier to perform useful operations.
(defn make-move
  "Move peg from p1 to p2, removing jumped peg"
  [board p1 p2]
  (if-let [jumped (valid-move? board p1 p2)]
    (move-peg (remove-peg board jumped) p1 p2)))
;; if-let is a nifty way to say,
;; “If an expression evaluates to a truthy value,
;; then bind that value to a name the same way that I can in a let expression.
;; Otherwise, if I’ve provided an else clause, perform that else clause;
;; if I haven’t provided an else clause, return nil.”
;; In this case, the test expression is (valid-move? board p1 p2),
;; and you’re assigning the result to the name jumped if the result is truthy.
;; That’s used in the call to move-peg,
;; which returns a new board.
;; You don’t supply an else clause,
;; so if the move isn’t valid, the return value of the whole expression is nil.

;; Finally, the function can-move? is used to determine whether the game is over
;; by finding the first pegged positions with moves available:
(defn can-move?
  "Do any of the pegged positions have valid moves?"
  [board]
  (some (comp not-empty (partial valid-moves board))
        (map first (filter #(get (second %) :pegged) board))))
;; The question mark at the end of this function name indicates it’s a predicate function,
;; a function that’s meant to be used in Boolean expressions.
;; Predicate is taken from predicate logic,
;; which concerns itself with determining whether a statement is true or false.
;; (You’ve already seen some built-in predicate functions, like empty? and every?.)
;; can-move? works by getting a sequence of all pegged positions
;; with (map first (filter #(get (second %) :pegged) board)).
;; You can break this down further into the filter and map function calls:
;; because filter is a seq function,
;; it converts board, a map, into a seq of two-element vectors (also called tuples),
;; which looks something like this:
'([1 {:connections {6 3, 4 2}, :pegged true}]
  [2 {:connections {9 5, 7 4}, :pegged true}])
;; The first element of the tuple is a position number,
;; and the second is that position’s information.
;; filter then applies the anonymous function #(get (second %) :pegged) to each of these tuples,
;; filtering out the tuples
;; where the position’s information indicates that the position is not currently housing a peg.
;; Finally, the result is passed to map,
;; which calls first on each tuple to grab just the position number from the tuples.

;; After you get a seq of pegged positions numbers,
;; you call a predicate function on each one to find the first position that returns a truthy value.
;; The predicate function is created with (comp not-empty (partial valid-moves board)).
;; The idea is to first return a map of all valid moves for a position
;; and then test whether that map is empty.

;; First, the expression (partial valid-moves board)
;; derives an anonymous function from valid-moves with the first argument, board,
;; filled in using partial (because you’re using the same board each time you call valid-moves).
;; The new function can take a position
;; and return the map of all its valid moves for the current board.

;; Second, you use comp to compose this function with not-empty.
;; This function is self-descriptive;
;; it returns true if the given collection is empty and false otherwise.

;; What’s most interesting about this bit of code is that
;; you’re using a chain of functions to derive a new function,
;; similar to how you use chains of functions to derive new data.
;; In Chapter 3, you learned that Clojure treats functions as data
;; in that functions can receive functions as arguments and return them.
;; Hopefully, this shows why that feature is fun and useful.

;; ================================
;; Rendering and Printing the Board
;; ================================

;; The first few expressions in the board representation
;; and printing section just define constants:
(def alpha-start 97)
(def alpha-end 123)
(def letters (map (comp str char) (range alpha-start alpha-end)))
(def pos-chars 3)
;; The bindings alpha-start and alpha-end
;; set up the beginning and end of the numerical values for the letters a through z.
;; We use those to build up a seq of letters.
;; char, when applied to an integer,
;; returns the character corresponding to that integer,
;; and str turns the char into a string.
;; pos-chars is used by the function row-padding
;; to determine how much spacing to add to the beginning of each row.

;; The next few definitions, ansi-styles, ansi, and colorize output colored text to the terminal.
;; REF: The code is here: https://github.com/flyingmachine/pegthing/blob/master/src/pegthing/core.clj
(def ansi-styles
  {:red   "[31m"
   :green "[32m"
   :blue  "[34m"
   :reset "[0m"})

(defn ansi
  "Produce a string which will apply an ansi style"
  [style]
  (str \u001b (style ansi-styles)))

(defn colorize
  "Apply ansi color to text"
  [text color]
  (str (ansi color) text (ansi :reset)))

;; The functions render-pos, row-positions, row-padding, and render-row create strings to represent the board:
(defn render-pos
  [board pos]
  (str (nth letters (dec pos))
       (if (get-in board [pos :pegged])
         (colorize "0" :blue)
         (colorize "-" :red))))

(defn row-positions
  "Return all positions in the given row"
  [row-num]
  (range (inc (or (row-tri (dec row-num)) 0))
         (inc (row-tri row-num))))

(defn row-padding
  "String of spaces to add to the beginning of a row to center it"
  [row-num rows]
  (let [pad-length (/ (* (- rows row-num) pos-chars) 2)]
    (apply str (take pad-length (repeat " ")))))

(defn render-row
  [board row-num]
  (str (row-padding row-num (:rows board))
       (clojure.string/join " " (map (partial render-pos board)
                                     (row-positions row-num)))))
;; Notice the expression (map (partial render-pos board) (row-positions row-num)).
;; This demonstrates a good use case for partials
;; by applying the same function multiple times with one or more arguments filled in,
;; just like in the can-move? function shown earlier.

;; Finally, print-board merely iterates over each row number with doseq,
;; printing the string representation of that row:
(defn print-board
  [board]
  (doseq [row-num (range 1 (inc (:rows board)))]
    (println (render-row board row-num))))
;; You use doseq when you want to perform side-effecting operations (like printing to a terminal)
;; on the elements of a collection.
;; The vector that immediately follows the name doseq
;; describes how to bind all the elements in a collection to a name
;; one at a time so you can operate on them.
;; In this instance, you’re assigning the numbers 1 through 5 (assuming there are five rows)
;; to the name row-num so you can print each row.

;; Although printing the board technically falls under interaction,
;; I wanted to show it here with the rendering functions.
;; When I first started writing this game,
;; the print-board function also generated the board’s string representation.
;; However, now print-board defers all rendering to pure functions,
;; which makes the code easier to understand
;; and decreases the surface area of our impure functions.

;; ================================
;; Player Interaction
;; ================================

;; The next collection of functions handles player interaction.
;; First, there’s letter->pos, which converts a letter
;; (which is how the positions are displayed and identified by players)
;; to the corresponding position number:
(defn letter->pos
  "Converts a letter string to the corresponding position number"
  [letter]
  (inc (- (int (first letter)) alpha-start)))

;; Next, the helper function get-input allows you to read and clean the player’s input.
;; You can also provide a default value,
;; which is used if the player presses enter without typing anything:
(defn get-input
  "Waits for user to enter text and hit enter, then cleans the input"
  ([] (get-input nil))
  ([default]
   (let [input (clojure.string/trim (read-line))]
     (if (empty? input)
       default
       (clojure.string/lower-case input)))))

;; The next function, characters-as-strings,
;; is a tiny helper function used by prompt-move
;; to take in a string and return a collection of letters with all nonalphabetic input discarded:
(defn characters-as-strings
  "Given a string, return a collection consisting of each individual
  character"
  [string]
  (re-seq #"[a-zA-Z]" string))

(characters-as-strings "a   b")
(characters-as-strings "a   cb")

;; Next, prompt-move reads the player’s input and acts on it:
(defn user-entered-valid-move
  "Handles the next step after a user has entered a valid move"
  [board]
  (if (can-move? board)
    (prompt-move board)
    (game-over board)))

(defn user-entered-invalid-move
  "Handles the next step after a user has entered an invalid move"
  [board]
  (println "\n!!! That was an invalid move :(\n")
  (prompt-move board))

(defn prompt-move
  [board]
  (println "\nHere's your board:")
  (print-board board)
  (println "Move from where to where? Enter two letters:")
  (let [input (map letter->pos (characters-as-strings (get-input)))]
    (if-let [new-board (make-move board (first input) (second input))]
      (user-entered-valid-move new-board)
      (user-entered-invalid-move board))))
;; make-move returns nil if the player’s move was invalid,
;; and you use that information to inform her of her mistake
;; with the user-entered-invalid-move function.
;; However, if the move is valid,
;; the new-board is passed off to user-entered-valid-move,
;; which hands control back to prompt-move if there are still moves to be made.
;; In our board creation functions,
;; we saw how recursion was used to build up a value using immutable data structures.
;; The same thing is happening here,
;; only it involves two mutually recursive functions and some user input.
;; No mutable attributes in sight!

;; What happens when the game is over? This is what happens:
(defn prompt-empty-peg
  [board]
  (println "Here's your board:")
  (print-board board)
  (println "Remove which peg? [e]")
  (prompt-move (remove-peg board (letter->pos (get-input "e")))))

(defn prompt-rows
  []
  (println "How many rows? [5]")
  (let [rows (Integer. (get-input 5))
        board (new-board rows)]
    (prompt-empty-peg board)))

(defn game-over
  "Announce the game is over and prompt to play again"
  [board]
  (let [remaining-pegs (count (filter :pegged (vals board)))]
    (println "Game over! You had" remaining-pegs "pegs left:")
    (print-board board)
    (println "Play again? y/n [y]")
    (let [input (get-input "y")]
      (if (= "y" input)
        (prompt-rows)
        (do
          (println "Bye!")
          (System/exit 0))))))
;; All that’s going on here is that the game tells you how you did,
;; prints the final board,
;; and prompts you to play again.
;; If you select y, the game calls prompt-rows,
;; which brings us to the final set of functions,
;; those used to start a new game.

;; You use prompt-rows to start a game,
;; getting the player’s input on how many rows to include.
;; Then you pass control on to prompt-empty-peg
;; so the player can tell the game which peg to remove first.
;; From there, the program prompts you for moves until there aren’t any moves left.

;; Even though all of this program’s side effects are relatively harmless
;; (all you’re doing is prompting and printing),
;; sequestering them in their own functions like this
;; is a best practice for functional programming.
;; In general, you will reap more benefits from functional programming
;; if you identify the bits of functionality that are referentially transparent and side-effect free,
;; and place those bits in their own functions.
;; These functions are not capable of causing bizarre bugs in unrelated parts of your program.
;; They’re easier to test and develop in the REPL
;; because they rely only on the arguments you pass them,
;; not on some complicated hidden state object.

;; ================================
;; Summary
;; ================================

;; Pure functions are referentially transparent and side-effect free,
;; which makes them easy to reason about.
;; To get the most from Clojure, try to keep your impure functions to a minimum.
;; In an immutable world, you use recursion instead of for/while loops,
;; and function composition instead of successions of mutations.
;; Pure functions allow powerful techniques like function composition functions and memoization.
;; They’re also super fun!

(defn -main
  [& args]
  (println "Get ready to play peg thing!")
  (prompt-rows))
